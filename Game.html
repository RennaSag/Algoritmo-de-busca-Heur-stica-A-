<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mundo da Barbie - Busca A*</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #ff69b4, #ffb6c1);
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        h1 {
            text-align: center;
            color: #d63384;
            font-size: 2.5em;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        button {
            background: linear-gradient(45deg, #ff69b4, #d63384);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(214, 51, 132, 0.3);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(214, 51, 132, 0.4);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .map-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            margin-bottom: 20px;
        }

        .map-wrapper {
            position: relative;
            border: 3px solid #d63384;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            background: white;
            padding: 20px;
        }

        .coordinates {
            position: absolute;
            font-size: 10px;
            color: #666;
            font-weight: bold;
        }

        .coord-top {
            top: 2px;
            left: 50px;
            right: 0;
            height: 15px;
            display: flex;
        }

        .coord-left {
            left: 2px;
            top: 35px;
            width: 15px;
            writing-mode: vertical-rl;
            text-orientation: mixed;
        }

        .coord-number {
            flex: 1;
            text-align: center;
            min-width: 16px;
        }

        .map {
            position: relative;
            font-size: 0;
            line-height: 0;
            margin-left: 20px;
            margin-top: 20px;
        }

        .cell {
            width: 16px;
            height: 16px;
            display: inline-block;
            border: 0.5px solid rgba(0,0,0,0.2);
            position: relative;
            transition: all 0.3s ease;
        }

        .cell:hover {
            transform: scale(1.2);
            z-index: 10;
            border: 2px solid #000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .info-panel {
            background: rgba(255, 182, 193, 0.3);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            border: 2px solid #ffb6c1;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-box {
            background: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .legend {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            border: 1px solid #333;
        }

        .log {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
        }

        .friends-status {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }

        .friend-card {
            background: white;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            border: 2px solid #ddd;
            transition: all 0.3s ease;
        }

        .friend-card.convinced {
            border-color: #28a745;
            background: #d4edda;
        }

        .friend-card.rejected {
            border-color: #dc3545;
            background: #f8d7da;
        }

        .friend-card.visited {
            border-color: #ffc107;
            background: #fff3cd;
        }

        /* Cores dos terrenos */
        .asfalto { background-color: #2c2c2c; }
        .grama { background-color: #228B22; }
        .terra { background-color: #8B4513; }
        .paralelepipedo { background-color: #A9A9A9; }
        .edificio { background-color: #FF8C00; }
        .barbie { 
            background-color: #FF1493; 
            animation: pulse 1s infinite;
            box-shadow: 0 0 10px #FF1493;
        }
        .friend { 
            background-color: #FFD700; 
            border: 2px solid #FFA500 !important;
            animation: glow 2s infinite alternate;
        }
        .path { 
            background-color: #00BFFF; 
            animation: pathGlow 0.5s ease-in-out;
        }
        .visited { background-color: #87CEEB; }
        
        .friend.convinced-friend { 
            background-color: #32CD32 !important; 
            animation: success 1s ease-in-out;
        }
        .friend.rejected-friend { 
            background-color: #DC143C !important; 
            animation: shake 0.5s ease-in-out;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }

        @keyframes glow {
            0% { box-shadow: 0 0 5px #FFD700; }
            100% { box-shadow: 0 0 15px #FFA500; }
        }

        @keyframes pathGlow {
            0% { background-color: #00BFFF; transform: scale(1); }
            50% { background-color: #87CEEB; transform: scale(1.1); }
            100% { background-color: #00BFFF; transform: scale(1); }
        }

        @keyframes success {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); background-color: #90EE90; }
            100% { transform: scale(1); }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-2px); }
            75% { transform: translateX(2px); }
        }

        .cell-info {
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 10px;
            white-space: nowrap;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .cell:hover .cell-info {
            opacity: 1;
        }

            @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .map-container {
                flex-direction: column;
                align-items: center;
            }
            
            .cell {
                width: 12px;
                height: 12px;
            }
            
            .coord-number {
                min-width: 12px;
            }
            
            .map-wrapper {
                padding: 10px;
            }
            
            .coordinates {
                font-size: 8px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🌟 Mundo da Barbie - Algoritmo A* 🌟</h1>
        
        <div class="controls">
            <button onclick="initializeGame()">🎮 Inicializar Jogo</button>
            <button onclick="startSearch()" id="startBtn" disabled>🚀 Iniciar Busca</button>
            <button onclick="resetGame()">🔄 Resetar</button>
            <button onclick="toggleSpeed()">⚡ Velocidade: <span id="speedText">Normal</span></button>
        </div>

        <div class="info-panel">
            <div class="stats">
                <div class="stat-box">
                    <h3>Posição Atual</h3>
                    <div id="currentPosition">[23, 19]</div>
                </div>
                <div class="stat-box">
                    <h3>Custo Atual</h3>
                    <div id="currentCost">0</div>
                </div>
                <div class="stat-box">
                    <h3>Pessoas Convencidas</h3>
                    <div id="convincedCount">0/3</div>
                </div>
                <div class="stat-box">
                    <h3>Status</h3>
                    <div id="gameStatus">Aguardando inicialização</div>
                </div>
            </div>

            <div class="friends-status" id="friendsStatus">
                <!-- Status dos amigos será inserido aqui -->
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color asfalto"></div>
                    <span>Asfalto (1 min)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color terra"></div>
                    <span>Terra (3 min)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color grama"></div>
                    <span>Grama (5 min)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color paralelepipedo"></div>
                    <span>Paralelepípedo (10 min)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color edificio"></div>
                    <span>Edifício (∞)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color barbie"></div>
                    <span>Barbie</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color friend"></div>
                    <span>Amigos</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color path"></div>
                    <span>Caminho</span>
                </div>
            </div>
        </div>

        <div class="map-container">
            <div class="map-wrapper">
                <h3 style="text-align: center; margin-bottom: 15px; margin-top: 0;">Mapa do Mundo da Barbie (42x42)</h3>
                
                <!-- Coordenadas superiores (colunas) -->
                <div class="coordinates coord-top" id="topCoords"></div>
                
                <!-- Coordenadas esquerdas (linhas) -->
                <div class="coordinates coord-left" id="leftCoords"></div>
                
                <div id="map" class="map"></div>
            </div>
            
            <div class="info-panel" style="max-width: 800px;">
                <h4>Instruções de Visualização</h4>
                <p><strong>Passe o mouse sobre qualquer célula</strong> para ver suas coordenadas [linha, coluna] e tipo de terreno.</p>
                <p><strong>Observe as animações:</strong> Barbie pulsa em rosa, amigos brilham em dourado, caminho percorrido fica azul.</p>
            </div>
        </div>

        <div class="info-panel">
            <h3>Log de Atividades</h3>
            <div id="log" class="log"></div>
        </div>
    </div>

    <script>
        // Configurações globais
        const GRID_SIZE = 42;
        const START_POS = [23, 19];
        let gameSpeed = 100; // ms entre movimentos
        
        // Custos dos terrenos
        const TERRAIN_COSTS = {
            asfalto: 1,
            terra: 3,
            grama: 5,
            paralelepipedo: 10,
            edificio: Infinity
        };

        // Estado do jogo
        let gameState = {
            map: [],
            friends: [],
            acceptingFriends: [],
            barbiePos: [...START_POS],
            convincedFriends: [],
            visitedFriends: [],
            currentCost: 0,
            path: [],
            visitedCells: new Set(),
            isRunning: false
        };

        // Posições dos amigos
        const FRIENDS = [
            { name: 'Suzy', pos: [5, 8] },
            { name: 'Polly', pos: [35, 12] },
            { name: 'Mary', pos: [8, 30] },
            { name: 'Carly', pos: [38, 35] },
            { name: 'Ken', pos: [15, 5] },
            { name: 'Brandon', pos: [25, 38] }
        ];

        // Mapa básico (será gerado proceduralmente)
        function generateMap() {
            const map = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill('grama'));
            
            // Adicionar estradas (asfalto)
            for (let i = 0; i < GRID_SIZE; i++) {
                if (i % 8 === 0) {
                    for (let j = 0; j < GRID_SIZE; j++) {
                        map[i][j] = 'asfalto';
                    }
                }
                if (i % 8 === 7) {
                    for (let j = 0; j < GRID_SIZE; j++) {
                        map[j][i] = 'asfalto';
                    }
                }
            }

            // Adicionar paralelepípedo em algumas áreas
            for (let i = 10; i < 20; i++) {
                for (let j = 10; j < 20; j++) {
                    if (Math.random() > 0.7) {
                        map[i][j] = 'paralelepipedo';
                    }
                }
            }

            // Adicionar terra em algumas áreas
            for (let i = 25; i < 35; i++) {
                for (let j = 25; j < 35; j++) {
                    if (Math.random() > 0.6) {
                        map[i][j] = 'terra';
                    }
                }
            }

            // Adicionar alguns edifícios
            const buildings = [
                [12, 12], [13, 12], [12, 13], [13, 13],
                [30, 8], [31, 8], [30, 9], [31, 9],
                [6, 25], [7, 25], [6, 26], [7, 26]
            ];

            buildings.forEach(([x, y]) => {
                if (x < GRID_SIZE && y < GRID_SIZE) {
                    map[x][y] = 'edificio';
                }
            });

            return map;
        }

        function initializeGame() {
            gameState.map = generateMap();
            gameState.friends = [...FRIENDS];
            gameState.barbiePos = [...START_POS];
            gameState.convincedFriends = [];
            gameState.visitedFriends = [];
            gameState.currentCost = 0;
            gameState.path = [];
            gameState.visitedCells = new Set();
            gameState.isRunning = false;

            // Sortear quais 3 amigos vão aceitar
            const shuffled = [...FRIENDS].sort(() => 0.5 - Math.random());
            gameState.acceptingFriends = shuffled.slice(0, 3).map(f => f.name);

            log(`🎮 Jogo inicializado! Amigos que vão aceitar: ${gameState.acceptingFriends.join(', ')}`);
            
            initializeCoordinates();
            updateDisplay();
            updateFriendsStatus();
            
            document.getElementById('startBtn').disabled = false;
            document.getElementById('gameStatus').textContent = 'Pronto para iniciar';
        }

        function startSearch() {
            if (gameState.isRunning) return;
            
            gameState.isRunning = true;
            document.getElementById('startBtn').disabled = true;
            document.getElementById('gameStatus').textContent = 'Executando busca A*';
            
            log('🚀 Iniciando busca A*...');
            
            executeAStarSearch();
        }

        function resetGame() {
            gameState.isRunning = false;
            gameState.barbiePos = [...START_POS];
            gameState.convincedFriends = [];
            gameState.visitedFriends = [];
            gameState.currentCost = 0;
            gameState.path = [];
            gameState.visitedCells = new Set();
            
            document.getElementById('startBtn').disabled = true;
            document.getElementById('gameStatus').textContent = 'Aguardando inicialização';
            
            updateDisplay();
            updateFriendsStatus();
            clearLog();
            
            log('🔄 Jogo resetado');
        }

        function toggleSpeed() {
            const speeds = [50, 100, 200, 500];
            const currentIndex = speeds.indexOf(gameSpeed);
            const nextIndex = (currentIndex + 1) % speeds.length;
            gameSpeed = speeds[nextIndex];
            
            const speedNames = ['Muito Rápida', 'Rápida', 'Normal', 'Lenta'];
            document.getElementById('speedText').textContent = speedNames[nextIndex];
        }

        // Implementação do algoritmo A*
        function heuristic(pos1, pos2) {
            return Math.abs(pos1[0] - pos2[0]) + Math.abs(pos1[1] - pos2[1]);
        }

        function getNeighbors(pos) {
            const [x, y] = pos;
            const neighbors = [];
            const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
            
            for (const [dx, dy] of directions) {
                const newX = x + dx;
                const newY = y + dy;
                
                if (newX >= 0 && newX < GRID_SIZE && newY >= 0 && newY < GRID_SIZE) {
                    const terrain = gameState.map[newX][newY];
                    if (terrain !== 'edificio') {
                        neighbors.push([newX, newY]);
                    }
                }
            }
            
            return neighbors;
        }

        function findPath(start, goal) {
            const openSet = [{ pos: start, g: 0, f: heuristic(start, goal), parent: null }];
            const closedSet = new Set();
            
            while (openSet.length > 0) {
                // Encontrar nó com menor f
                openSet.sort((a, b) => a.f - b.f);
                const current = openSet.shift();
                
                const posKey = `${current.pos[0]},${current.pos[1]}`;
                if (closedSet.has(posKey)) continue;
                closedSet.add(posKey);
                
                // Verificar se chegou ao objetivo
                if (current.pos[0] === goal[0] && current.pos[1] === goal[1]) {
                    const path = [];
                    let node = current;
                    while (node) {
                        path.unshift([...node.pos]);
                        node = node.parent;
                    }
                    return { path, cost: current.g };
                }
                
                // Explorar vizinhos
                for (const neighborPos of getNeighbors(current.pos)) {
                    const neighborKey = `${neighborPos[0]},${neighborPos[1]}`;
                    if (closedSet.has(neighborKey)) continue;
                    
                    const terrain = gameState.map[neighborPos[0]][neighborPos[1]];
                    const moveCost = TERRAIN_COSTS[terrain];
                    const g = current.g + moveCost;
                    const h = heuristic(neighborPos, goal);
                    const f = g + h;
                    
                    const existing = openSet.find(node => 
                        node.pos[0] === neighborPos[0] && node.pos[1] === neighborPos[1]
                    );
                    
                    if (!existing || g < existing.g) {
                        const newNode = {
                            pos: neighborPos,
                            g: g,
                            f: f,
                            parent: current
                        };
                        
                        if (existing) {
                            const index = openSet.indexOf(existing);
                            openSet[index] = newNode;
                        } else {
                            openSet.push(newNode);
                        }
                    }
                }
            }
            
            return null; // Caminho não encontrado
        }

        async function executeAStarSearch() {
            let totalCost = 0;
            
            while (gameState.convincedFriends.length < 3 && gameState.isRunning) {
                // Encontrar o próximo amigo mais próximo não visitado
                const availableFriends = gameState.friends.filter(friend => 
                    !gameState.visitedFriends.includes(friend.name)
                );
                
                if (availableFriends.length === 0) {
                    log('❌ Não há mais amigos para visitar!');
                    break;
                }
                
                // Calcular distâncias e escolher o mais próximo
                let closestFriend = null;
                let shortestPath = null;
                let minCost = Infinity;
                
                for (const friend of availableFriends) {
                    const pathResult = findPath(gameState.barbiePos, friend.pos);
                    if (pathResult && pathResult.cost < minCost) {
                        minCost = pathResult.cost;
                        closestFriend = friend;
                        shortestPath = pathResult;
                    }
                }
                
                if (!closestFriend) {
                    log('❌ Não foi possível encontrar caminho para nenhum amigo!');
                    break;
                }
                
                log(`🎯 Indo visitar ${closestFriend.name} na posição [${closestFriend.pos}]`);
                log(`📍 Caminho encontrado com custo: ${shortestPath.cost} minutos`);
                
                // Mover ao longo do caminho
                for (let i = 1; i < shortestPath.path.length; i++) {
                    if (!gameState.isRunning) break;
                    
                    const prevPos = [...gameState.barbiePos];
                    gameState.barbiePos = [...shortestPath.path[i]];
                    
                    // Marcar célula anterior como visitada
                    gameState.visitedCells.add(`${prevPos[0]},${prevPos[1]}`);
                    
                    const terrain = gameState.map[gameState.barbiePos[0]][gameState.barbiePos[1]];
                    const stepCost = TERRAIN_COSTS[terrain];
                    totalCost += stepCost;
                    gameState.currentCost = totalCost;
                    
                    log(`👣 Movendo para [${gameState.barbiePos[0]}, ${gameState.barbiePos[1]}] - Terreno: ${terrain} (${stepCost} min)`);
                    
                    updateDisplay();
                    await sleep(gameSpeed);
                }
                
                // Tentar convencer o amigo
                gameState.visitedFriends.push(closestFriend.name);
                const willAccept = gameState.acceptingFriends.includes(closestFriend.name);
                
                // Animação especial para a resposta do amigo
                const friendElement = document.querySelector(`[data-friend="${closestFriend.name}"]`);
                
                if (willAccept) {
                    gameState.convincedFriends.push(closestFriend.name);
                    log(`✅ ${closestFriend.name} aceitou participar do concurso!`);
                    if (friendElement) {
                        friendElement.classList.add('convinced-friend');
                    }
                } else {
                    log(`❌ ${closestFriend.name} recusou o convite.`);
                    if (friendElement) {
                        friendElement.classList.add('rejected-friend');
                    }
                }
                
                updateFriendsStatus();
                updateDisplay();
                await sleep(gameSpeed * 3); // Pausa mais longa para mostrar a resposta
            }
            
            // Retornar para casa se conseguiu convencer 3 pessoas
            if (gameState.convincedFriends.length === 3) {
                log('🎉 Missão cumprida! Retornando para casa...');
                const returnPath = findPath(gameState.barbiePos, START_POS);
                
                if (returnPath) {
                    for (let i = 1; i < returnPath.path.length; i++) {
                        if (!gameState.isRunning) break;
                        
                        const prevPos = [...gameState.barbiePos];
                        gameState.barbiePos = [...returnPath.path[i]];
                        
                        // Marcar célula anterior como visitada
                        gameState.visitedCells.add(`${prevPos[0]},${prevPos[1]}`);
                        
                        const terrain = gameState.map[gameState.barbiePos[0]][gameState.barbiePos[1]];
                        const stepCost = TERRAIN_COSTS[terrain];
                        totalCost += stepCost;
                        gameState.currentCost = totalCost;
                        
                        log(`🏠 Retornando para casa: [${gameState.barbiePos[0]}, ${gameState.barbiePos[1]}] - ${terrain} (${stepCost} min)`);
                        
                        updateDisplay();
                        await sleep(gameSpeed);
                    }
                    
                    log(`🏠 Barbie chegou em casa! Custo total: ${totalCost} minutos`);
                    document.getElementById('gameStatus').textContent = `Missão concluída! Custo: ${totalCost} min`;
                } else {
                    log('❌ Não foi possível encontrar caminho de volta para casa!');
                }
            } else {
                log(`❌ Missão falhou! Apenas ${gameState.convincedFriends.length} pessoas foram convencidas.`);
                document.getElementById('gameStatus').textContent = 'Missão falhou';
            }
            
            gameState.isRunning = false;
            document.getElementById('startBtn').disabled = false;
        }

        function updateDisplay() {
            const mapElement = document.getElementById('map');
            let html = '';
            
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    let className = gameState.map[i][j];
                    let cellContent = '';
                    let dataAttributes = '';
                    
                    // Verificar se foi visitada (mostrar rastro)
                    if (gameState.visitedCells.has(`${i},${j}`)) {
                        className += ' visited';
                    }
                    
                    // Verificar se é posição da Barbie
                    if (i === gameState.barbiePos[0] && j === gameState.barbiePos[1]) {
                        className = 'barbie';
                        cellContent = '👑';
                    }
                    // Verificar se é posição de um amigo
                    else {
                        const friend = gameState.friends.find(f => f.pos[0] === i && f.pos[1] === j);
                        if (friend) {
                            className = 'friend';
                            dataAttributes = `data-friend="${friend.name}"`;
                            
                            if (gameState.convincedFriends.includes(friend.name)) {
                                className += ' convinced-friend';
                                cellContent = '✅';
                            } else if (gameState.visitedFriends.includes(friend.name)) {
                                className += ' rejected-friend';
                                cellContent = '❌';
                            } else {
                                cellContent = friend.name[0]; // Primeira letra do nome
                            }
                        }
                    }
                    
                    const terrainName = gameState.map[i][j];
                    const cost = TERRAIN_COSTS[terrainName];
                    const costText = cost === Infinity ? '∞' : cost;
                    
                    html += `<div class="cell ${className}" ${dataAttributes}>
                        ${cellContent}
                        <div class="cell-info">[${i},${j}] - ${terrainName} (${costText}min)</div>
                    </div>`;
                }
                html += '<br>';
            }
            
            mapElement.innerHTML = html;
            
            // Atualizar estatísticas
            document.getElementById('currentPosition').textContent = `[${gameState.barbiePos[0]}, ${gameState.barbiePos[1]}]`;
            document.getElementById('currentCost').textContent = `${gameState.currentCost} min`;
            document.getElementById('convincedCount').textContent = `${gameState.convincedFriends.length}/3`;
        }

        function updateFriendsStatus() {
            const container = document.getElementById('friendsStatus');
            let html = '';
            
            for (const friend of gameState.friends) {
                let status = '';
                let className = '';
                
                if (gameState.convincedFriends.includes(friend.name)) {
                    status = '✅ Convencido';
                    className = 'convinced';
                } else if (gameState.visitedFriends.includes(friend.name)) {
                    status = '❌ Recusou';
                    className = 'rejected';
                } else {
                    status = '⏳ Não visitado';
                    className = '';
                }
                
                html += `
                    <div class="friend-card ${className}">
                        <strong>${friend.name}</strong><br>
                        <small>[${friend.pos[0]}, ${friend.pos[1]}]</small><br>
                        <span>${status}</span>
                    </div>
                `;
            }
            
            container.innerHTML = html;
        }

        function log(message) {
            const logElement = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            logElement.innerHTML += `[${timestamp}] ${message}\n`;
            logElement.scrollTop = logElement.scrollHeight;
        }

        function clearLog() {
            document.getElementById('log').innerHTML = '';
        }

        function initializeCoordinates() {
            // Coordenadas superiores (colunas)
            const topCoords = document.getElementById('topCoords');
            let topHTML = '';
            for (let j = 0; j < GRID_SIZE; j++) {
                if (j % 5 === 0) { // Mostrar números a cada 5 colunas
                    topHTML += `<div class="coord-number">${j}</div>`;
                } else {
                    topHTML += `<div class="coord-number"></div>`;
                }
            }
            topCoords.innerHTML = topHTML;
            
            // Coordenadas esquerdas (linhas)
            const leftCoords = document.getElementById('leftCoords');
            let leftHTML = '';
            for (let i = 0; i < GRID_SIZE; i++) {
                if (i % 5 === 0) { // Mostrar números a cada 5 linhas
                    leftHTML += `<div class="coord-number" style="height: 80px; display: flex; align-items: center;">${i}</div>`;
                } else {
                    leftHTML += `<div class="coord-number" style="height: 80px;"></div>`;
                }
            }
            leftCoords.innerHTML = leftHTML;
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Inicialização
        window.onload = function() {
            initializeCoordinates();
            updateDisplay();
            log('🌟 Sistema carregado! Clique em "Inicializar Jogo" para começar.');
        };
    </script>
</body>
</html>